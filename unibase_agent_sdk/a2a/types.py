"""A2A Protocol type definitions.

Implements the A2A protocol data model following the official specification:
https://a2a-protocol.org/latest/specification/

Core concepts:
- Task: Fundamental unit of work with lifecycle states
- Message: Communication turn between client and agent
- Part: Content unit (text, file, or structured data)
- Artifact: Output generated by an agent
- AgentCard: JSON metadata describing agent capabilities
"""

from typing import Optional, Dict, Any, List, Union
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timezone
import uuid


class TaskState(Enum):
    """Task lifecycle states.
    
    A task progresses through these states during its lifecycle:
    - SUBMITTED: Task received but not yet started
    - WORKING: Agent is actively processing the task
    - INPUT_REQUIRED: Agent needs additional input from client
    - COMPLETED: Task finished successfully
    - FAILED: Task encountered an error
    - CANCELED: Task was canceled by client
    """
    SUBMITTED = "submitted"
    WORKING = "working"
    INPUT_REQUIRED = "input-required"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELED = "canceled"


class Role(Enum):
    """Message role indicating the sender."""
    USER = "user"
    AGENT = "agent"


@dataclass
class TextPart:
    """Text content part."""
    text: str
    
    def to_dict(self) -> Dict[str, Any]:
        return {"type": "text", "text": self.text}


@dataclass
class FilePart:
    """File content part.
    
    The file can be provided either as:
    - bytes: Raw file data (will be base64 encoded)
    - uri: URL to fetch the file from
    """
    name: str
    mime_type: str
    bytes: Optional[str] = None  # Base64 encoded
    uri: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "type": "file",
            "file": {
                "name": self.name,
                "mimeType": self.mime_type,
            }
        }
        if self.bytes:
            result["file"]["bytes"] = self.bytes
        if self.uri:
            result["file"]["uri"] = self.uri
        return result


@dataclass
class DataPart:
    """Structured data part (JSON)."""
    data: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        return {"type": "data", "data": self.data}


# Union type for all part types
Part = Union[TextPart, FilePart, DataPart]


def part_to_dict(part: Part) -> Dict[str, Any]:
    """Convert a Part to dictionary representation."""
    return part.to_dict()


def dict_to_part(data: Dict[str, Any]) -> Part:
    """Convert dictionary to appropriate Part type."""
    part_type = data.get("type")
    if part_type == "text":
        return TextPart(text=data["text"])
    elif part_type == "file":
        file_data = data["file"]
        return FilePart(
            name=file_data["name"],
            mime_type=file_data["mimeType"],
            bytes=file_data.get("bytes"),
            uri=file_data.get("uri")
        )
    elif part_type == "data":
        return DataPart(data=data["data"])
    else:
        raise ValueError(f"Unknown part type: {part_type}")


@dataclass
class Message:
    """A communication turn between client and agent.
    
    Attributes:
        role: "user" for client messages, "agent" for agent responses
        parts: List of content parts (text, files, or structured data)
        metadata: Optional key-value metadata
    """
    role: Role
    parts: List[Part]
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "role": self.role.value,
            "parts": [part_to_dict(p) for p in self.parts]
        }
        if self.metadata:
            result["metadata"] = self.metadata
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Message":
        return cls(
            role=Role(data["role"]),
            parts=[dict_to_part(p) for p in data.get("parts", [])],
            metadata=data.get("metadata")
        )
    
    @classmethod
    def user(cls, text: str) -> "Message":
        """Create a simple text message from user."""
        return cls(role=Role.USER, parts=[TextPart(text=text)])
    
    @classmethod
    def agent(cls, text: str) -> "Message":
        """Create a simple text message from agent."""
        return cls(role=Role.AGENT, parts=[TextPart(text=text)])


@dataclass
class Artifact:
    """Output generated by an agent.
    
    Artifacts represent results of task execution (documents, images, etc.).
    
    Attributes:
        name: Display name for the artifact
        parts: Content parts making up the artifact
        index: Ordering index for multiple artifacts
        append: Whether content appends to existing artifact
        last_chunk: Whether this is the final chunk (for streaming)
        metadata: Optional key-value metadata
    """
    name: str
    parts: List[Part]
    index: int = 0
    append: bool = False
    last_chunk: bool = True
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "name": self.name,
            "parts": [part_to_dict(p) for p in self.parts],
            "index": self.index,
            "append": self.append,
            "lastChunk": self.last_chunk,
        }
        if self.metadata:
            result["metadata"] = self.metadata
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Artifact":
        return cls(
            name=data["name"],
            parts=[dict_to_part(p) for p in data.get("parts", [])],
            index=data.get("index", 0),
            append=data.get("append", False),
            last_chunk=data.get("lastChunk", True),
            metadata=data.get("metadata")
        )


@dataclass
class TaskStatus:
    """Current status of a task.
    
    Attributes:
        state: Current lifecycle state
        message: Optional human-readable status message
        timestamp: When this status was set
    """
    state: TaskState
    message: Optional[Message] = None
    timestamp: Optional[str] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "state": self.state.value,
            "timestamp": self.timestamp,
        }
        if self.message:
            result["message"] = self.message.to_dict()
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TaskStatus":
        return cls(
            state=TaskState(data["state"]),
            message=Message.from_dict(data["message"]) if data.get("message") else None,
            timestamp=data.get("timestamp")
        )


@dataclass
class Task:
    """Fundamental unit of work in A2A protocol.
    
    Tasks have a lifecycle from submission through completion/failure,
    and can accumulate messages and artifacts during processing.
    
    Attributes:
        id: Unique task identifier
        status: Current task status
        context_id: Optional grouping context for related tasks
        artifacts: Output artifacts generated during task execution
        history: Message history for multi-turn interactions
        metadata: Optional key-value metadata
    """
    id: str
    status: TaskStatus
    context_id: Optional[str] = None
    artifacts: List[Artifact] = field(default_factory=list)
    history: List[Message] = field(default_factory=list)
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        if self.id is None:
            self.id = str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "id": self.id,
            "status": self.status.to_dict(),
        }
        if self.context_id:
            result["contextId"] = self.context_id
        if self.artifacts:
            result["artifacts"] = [a.to_dict() for a in self.artifacts]
        if self.history:
            result["history"] = [m.to_dict() for m in self.history]
        if self.metadata:
            result["metadata"] = self.metadata
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Task":
        return cls(
            id=data["id"],
            status=TaskStatus.from_dict(data["status"]),
            context_id=data.get("contextId"),
            artifacts=[Artifact.from_dict(a) for a in data.get("artifacts", [])],
            history=[Message.from_dict(m) for m in data.get("history", [])],
            metadata=data.get("metadata")
        )
    
    @classmethod
    def create(cls, message: Optional[Message] = None) -> "Task":
        """Create a new task in submitted state."""
        task = cls(
            id=str(uuid.uuid4()),
            status=TaskStatus(state=TaskState.SUBMITTED)
        )
        if message:
            task.history.append(message)
        return task


# ============================================================
# Streaming Events
# ============================================================

@dataclass
class TaskStatusUpdateEvent:
    """Event for task status changes (used in streaming)."""
    task_id: str
    context_id: Optional[str]
    status: TaskStatus
    final: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "taskId": self.task_id,
            "status": self.status.to_dict(),
            "final": self.final,
        }
        if self.context_id:
            result["contextId"] = self.context_id
        return result


@dataclass
class TaskArtifactUpdateEvent:
    """Event for artifact updates (used in streaming)."""
    task_id: str
    context_id: Optional[str]
    artifact: Artifact
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "taskId": self.task_id,
            "artifact": self.artifact.to_dict(),
        }
        if self.context_id:
            result["contextId"] = self.context_id
        return result


@dataclass  
class StreamResponse:
    """Wrapper for streaming responses.
    
    Contains exactly one of: task, message, statusUpdate, artifactUpdate
    """
    task: Optional[Task] = None
    message: Optional[Message] = None
    status_update: Optional[TaskStatusUpdateEvent] = None
    artifact_update: Optional[TaskArtifactUpdateEvent] = None
    
    def to_dict(self) -> Dict[str, Any]:
        if self.task:
            return {"task": self.task.to_dict()}
        elif self.message:
            return {"message": self.message.to_dict()}
        elif self.status_update:
            return {"statusUpdate": self.status_update.to_dict()}
        elif self.artifact_update:
            return {"artifactUpdate": self.artifact_update.to_dict()}
        return {}


# ============================================================
# Agent Discovery Types
# ============================================================

@dataclass
class Skill:
    """An agent skill/capability.
    
    Skills describe what an agent can do, helping clients
    find the right agent for a task.
    
    Attributes:
        id: Unique skill identifier
        name: Human-readable skill name
        description: Detailed description of the skill
        tags: Keywords for discovery
        examples: Example prompts/inputs
        input_modes: Supported input MIME types
        output_modes: Supported output MIME types
    """
    id: str
    name: str
    description: str
    tags: List[str] = field(default_factory=list)
    examples: List[str] = field(default_factory=list)
    input_modes: List[str] = field(default_factory=lambda: ["text/plain", "application/json"])
    output_modes: List[str] = field(default_factory=lambda: ["text/plain", "application/json"])
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "tags": self.tags,
            "examples": self.examples,
            "inputModes": self.input_modes,
            "outputModes": self.output_modes,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Skill":
        return cls(
            id=data["id"],
            name=data["name"],
            description=data["description"],
            tags=data.get("tags", []),
            examples=data.get("examples", []),
            input_modes=data.get("inputModes", ["text/plain"]),
            output_modes=data.get("outputModes", ["text/plain"])
        )


@dataclass
class Capability:
    """Agent capabilities configuration."""
    streaming: bool = True
    push_notifications: bool = False
    state_transition_history: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "streaming": self.streaming,
            "pushNotifications": self.push_notifications,
            "stateTransitionHistory": self.state_transition_history,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Capability":
        return cls(
            streaming=data.get("streaming", True),
            push_notifications=data.get("pushNotifications", False),
            state_transition_history=data.get("stateTransitionHistory", True)
        )


@dataclass
class Provider:
    """Agent provider information."""
    organization: str
    url: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {"organization": self.organization}
        if self.url:
            result["url"] = self.url
        return result


@dataclass
class SupportedInterface:
    """A supported protocol binding for the agent."""
    url: str
    protocol_binding: str  # "JSONRPC", "GRPC", "HTTP+JSON"
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "url": self.url,
            "protocolBinding": self.protocol_binding,
        }


@dataclass
class AgentCard:
    """Agent Card - JSON metadata describing an agent.
    
    Agent Cards are published at /.well-known/agent.json to enable
    agent discovery and capability advertisement.
    
    Attributes:
        name: Agent display name
        description: Human-readable description
        url: Base URL for the agent's A2A endpoint
        version: Agent version string
        protocol_version: A2A protocol version supported
        supported_interfaces: List of protocol bindings
        capabilities: Streaming, push notifications, etc.
        skills: List of agent skills
        provider: Organization information
        icon_url: URL to agent icon
        documentation_url: URL to documentation
        default_input_modes: Default supported input MIME types
        default_output_modes: Default supported output MIME types
    """
    name: str
    description: str
    url: str
    version: str = "1.0.0"
    protocol_version: str = "0.3.0"
    supported_interfaces: List[SupportedInterface] = field(default_factory=list)
    capabilities: Capability = field(default_factory=Capability)
    skills: List[Skill] = field(default_factory=list)
    provider: Optional[Provider] = None
    icon_url: Optional[str] = None
    documentation_url: Optional[str] = None
    default_input_modes: List[str] = field(default_factory=lambda: ["text/plain", "application/json"])
    default_output_modes: List[str] = field(default_factory=lambda: ["text/plain", "application/json"])
    
    def __post_init__(self):
        # Add default interface if none provided
        if not self.supported_interfaces:
            self.supported_interfaces = [
                SupportedInterface(url=self.url, protocol_binding="JSONRPC")
            ]
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "protocolVersion": self.protocol_version,
            "name": self.name,
            "description": self.description,
            "version": self.version,
            "supportedInterfaces": [i.to_dict() for i in self.supported_interfaces],
            "capabilities": self.capabilities.to_dict(),
            "skills": [s.to_dict() for s in self.skills],
            "defaultInputModes": self.default_input_modes,
            "defaultOutputModes": self.default_output_modes,
        }
        if self.provider:
            result["provider"] = self.provider.to_dict()
        if self.icon_url:
            result["iconUrl"] = self.icon_url
        if self.documentation_url:
            result["documentationUrl"] = self.documentation_url
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AgentCard":
        return cls(
            name=data["name"],
            description=data["description"],
            url=data.get("supportedInterfaces", [{}])[0].get("url", ""),
            version=data.get("version", "1.0.0"),
            protocol_version=data.get("protocolVersion", "0.3.0"),
            supported_interfaces=[
                SupportedInterface(
                    url=i["url"],
                    protocol_binding=i["protocolBinding"]
                ) for i in data.get("supportedInterfaces", [])
            ],
            capabilities=Capability.from_dict(data.get("capabilities", {})),
            skills=[Skill.from_dict(s) for s in data.get("skills", [])],
            provider=Provider(
                organization=data["provider"]["organization"],
                url=data["provider"].get("url")
            ) if data.get("provider") else None,
            icon_url=data.get("iconUrl"),
            documentation_url=data.get("documentationUrl"),
            default_input_modes=data.get("defaultInputModes", ["text/plain"]),
            default_output_modes=data.get("defaultOutputModes", ["text/plain"])
        )
    
    def to_json(self) -> str:
        """Serialize to JSON string."""
        import json
        return json.dumps(self.to_dict(), indent=2)


# ============================================================
# Push Notification Types
# ============================================================

@dataclass
class PushNotificationAuthenticationInfo:
    """Authentication info for push notification webhooks."""
    schemes: List[str]  # e.g., ["Bearer"]
    credentials: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {"schemes": self.schemes}
        if self.credentials:
            result["credentials"] = self.credentials
        return result


@dataclass
class PushNotificationConfig:
    """Configuration for push notifications.
    
    Clients can configure a webhook URL to receive async
    task updates when not connected via streaming.
    """
    url: str
    token: Optional[str] = None
    authentication: Optional[PushNotificationAuthenticationInfo] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {"url": self.url}
        if self.token:
            result["token"] = self.token
        if self.authentication:
            result["authentication"] = self.authentication.to_dict()
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PushNotificationConfig":
        auth = data.get("authentication")
        return cls(
            url=data["url"],
            token=data.get("token"),
            authentication=PushNotificationAuthenticationInfo(
                schemes=auth["schemes"],
                credentials=auth.get("credentials")
            ) if auth else None
        )


# ============================================================
# JSON-RPC Types
# ============================================================

@dataclass
class JSONRPCRequest:
    """JSON-RPC 2.0 request."""
    method: str
    params: Dict[str, Any] = field(default_factory=dict)
    id: Optional[Union[str, int]] = None
    jsonrpc: str = "2.0"
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "jsonrpc": self.jsonrpc,
            "method": self.method,
        }
        if self.params:
            result["params"] = self.params
        if self.id is not None:
            result["id"] = self.id
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "JSONRPCRequest":
        return cls(
            method=data["method"],
            params=data.get("params", {}),
            id=data.get("id"),
            jsonrpc=data.get("jsonrpc", "2.0")
        )


@dataclass
class JSONRPCError:
    """JSON-RPC 2.0 error."""
    code: int
    message: str
    data: Optional[Any] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {"code": self.code, "message": self.message}
        if self.data is not None:
            result["data"] = self.data
        return result


@dataclass
class JSONRPCResponse:
    """JSON-RPC 2.0 response."""
    id: Optional[Union[str, int]]
    result: Optional[Any] = None
    error: Optional[JSONRPCError] = None
    jsonrpc: str = "2.0"
    
    def to_dict(self) -> Dict[str, Any]:
        result = {"jsonrpc": self.jsonrpc, "id": self.id}
        if self.error:
            result["error"] = self.error.to_dict()
        else:
            result["result"] = self.result
        return result


# Standard A2A error codes
class A2AErrorCode:
    """Standard A2A protocol error codes."""
    PARSE_ERROR = -32700
    INVALID_REQUEST = -32600
    METHOD_NOT_FOUND = -32601
    INVALID_PARAMS = -32602
    INTERNAL_ERROR = -32603
    
    # A2A specific errors
    TASK_NOT_FOUND = -32001
    TASK_NOT_CANCELABLE = -32002
    PUSH_NOTIFICATION_NOT_SUPPORTED = -32003
    UNSUPPORTED_OPERATION = -32004
    CONTENT_TYPE_NOT_SUPPORTED = -32005
